CREATE EXTENSION IF NOT EXISTS moddatetime
	SCHEMA "extensions";
    
CREATE TABLE IF NOT EXISTS public.note
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    data text COLLATE pg_catalog."default" DEFAULT ''::text,
    tags text[] COLLATE pg_catalog."default",
    is_deleted boolean DEFAULT false,
    owner_id uuid,
    CONSTRAINT note_pkey PRIMARY KEY (id),
    CONSTRAINT note_owner_id_fkey FOREIGN KEY (owner_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.note
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.note
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.note TO anon;

GRANT ALL ON TABLE public.note TO authenticated;

GRANT ALL ON TABLE public.note TO postgres;

GRANT ALL ON TABLE public.note TO service_role;

GRANT ALL ON TABLE public.note TO supabase_admin;
CREATE POLICY "Delete for Owner or Public"
    ON public.note
    AS PERMISSIVE
    FOR DELETE
    TO public
    USING (((auth.uid() = owner_id) OR (owner_id IS NULL)));
CREATE POLICY "Enable access to Owner or All users"
    ON public.note
    AS PERMISSIVE
    FOR SELECT
    TO public
    USING (((auth.uid() = owner_id) OR (owner_id IS NULL)));
CREATE POLICY "Insert for All"
    ON public.note
    AS PERMISSIVE
    FOR INSERT
    TO anon, authenticated
    WITH CHECK (true);
CREATE POLICY "Update Owner or Public"
    ON public.note
    AS PERMISSIVE
    FOR UPDATE
    TO anon, authenticated
    USING (((auth.uid() = owner_id) OR (owner_id IS NULL)));

CREATE TRIGGER handle_updated_at
    BEFORE UPDATE 
    ON public.note
    FOR EACH ROW
    EXECUTE FUNCTION extensions.moddatetime('updated_at');

CREATE TABLE IF NOT EXISTS public.note_template
(
    id uuid NOT NULL DEFAULT uuid_generate_v4(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    data text COLLATE pg_catalog."default",
    tags text[] COLLATE pg_catalog."default" DEFAULT '{}'::text[],
    CONSTRAINT note_template_pkey PRIMARY KEY (id)
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.note_template
    OWNER to supabase_admin;

GRANT ALL ON TABLE public.note_template TO anon;

GRANT ALL ON TABLE public.note_template TO authenticated;

GRANT ALL ON TABLE public.note_template TO postgres;

GRANT ALL ON TABLE public.note_template TO service_role;

GRANT ALL ON TABLE public.note_template TO supabase_admin;


CREATE TABLE IF NOT EXISTS public.user_pin_note
(
    id bigint NOT NULL GENERATED BY DEFAULT AS IDENTITY ( INCREMENT 1 START 1 MINVALUE 1 MAXVALUE 9223372036854775807 CACHE 1 ),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    user_id uuid NOT NULL,
    note_id uuid NOT NULL,
    CONSTRAINT user_pin_note_pkey PRIMARY KEY (id, user_id, note_id),
    CONSTRAINT user_pin_note_note_id_fkey FOREIGN KEY (note_id)
        REFERENCES public.note (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION,
    CONSTRAINT user_pin_note_user_id_fkey FOREIGN KEY (user_id)
        REFERENCES auth.users (id) MATCH SIMPLE
        ON UPDATE NO ACTION
        ON DELETE NO ACTION
)

TABLESPACE pg_default;

ALTER TABLE IF EXISTS public.user_pin_note
    OWNER to supabase_admin;

ALTER TABLE IF EXISTS public.user_pin_note
    ENABLE ROW LEVEL SECURITY;

GRANT ALL ON TABLE public.user_pin_note TO supabase_admin;

GRANT ALL ON TABLE public.user_pin_note TO authenticated;

GRANT ALL ON TABLE public.user_pin_note TO anon;

GRANT ALL ON TABLE public.user_pin_note TO postgres;

GRANT ALL ON TABLE public.user_pin_note TO service_role;
